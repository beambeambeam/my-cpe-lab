\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{array}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}

\lstset{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    frame=single,
    breaklines=true
}

\InputIfFileExists{lab03-header.tex}{}{
    \newcommand{\TeamName}{Team name here}
    \newcommand{\MemberOne}{Member 1 name here}
    \newcommand{\MemberOneCode}{Member 1 code here}
    \newcommand{\MemberTwo}{Member 2 name here}
    \newcommand{\MemberTwoCode}{Member 2 code here}
}

\begin{document}

\begin{center}
\section*{Problem Session 3: Assembly Language}
\section*{Quick Sort}
\textbf{Team: \TeamName}\\
\textit{\MemberOne\ (\MemberOneCode)}\\
\textit{\MemberTwo\ (\MemberTwoCode)}
\end{center}

\subsection*{C Source Code}

This program sorts an integer array using Quick Sort with the Lomuto partition scheme. \texttt{swap\_int} swaps two integers via pointers. \texttt{partition} chooses the pivot as \texttt{arr[right]}, sets index \texttt{i = left - 1}, then loops \texttt{j} from \texttt{left} to \texttt{right - 1}; when \texttt{arr[j] <= pivot}, it increments \texttt{i} and swaps \texttt{arr[i]} with \texttt{arr[j]}. After the loop it swaps \texttt{arr[i+1]} with \texttt{arr[right]} and returns \texttt{i+1} as the pivot index. \texttt{quicksort} returns when \texttt{left >= right}; otherwise it calls \texttt{partition}, then recurses on the left subarray \texttt{left..p-1} and the right subarray \texttt{p+1..right}. \texttt{main} defines the array \texttt{\{10, 12, 8, 1, 5, 7, 11, 6, 8\}}, calls \texttt{quicksort(data, 0, n-1)}, then prints the sorted elements.

\begin{lstlisting}[language=C]
#include <stdio.h>

static void swap_int(int *a, int *b) {
  int tmp = *a;
  *a = *b;
  *b = tmp;
}

static int partition(int *arr, int left, int right) {
  const int pivot = arr[right];
  int i = left - 1;

  for (int j = left; j < right; j++) {
    if (arr[j] <= pivot) {
      i++;
      swap_int(&arr[i], &arr[j]);
    }
  }

  swap_int(&arr[i + 1], &arr[right]);
  return i + 1;
}

static void quicksort(int *arr, int left, int right) {
  if (left >= right) {
    return;
  }

  const int p = partition(arr, left, right);
  quicksort(arr, left, p - 1);
  quicksort(arr, p + 1, right);
}

int main() {
  int data[] = {10, 12, 8, 1, 5, 7, 11, 6, 8};
  const int n = (int)(sizeof(data) / sizeof(data[0]));

  quicksort(data, 0, n - 1);

  for (int i = 0; i < n; i++) {
    printf("%d%s", data[i], (i + 1 == n) ? "\n" : " ");
  }

  return 0;
}
\end{lstlisting}

\subsection*{ARM Assembly}

The ARM implementation targets the visUAL2 emulator and follows the same Lomuto Quick Sort algorithm with the same 9-element array.

\begin{itemize}
    \item \textbf{Data and entry:} The array is defined with \texttt{Data DCD 10, 12, 8, 1, 5, 7, 11, 6, 8}. The entry code loads the base address into R0, sets R1 = 0 (left) and R2 = 8 (right, last index for 9 elements), then branches to \texttt{QUICKSORT}.
    \item \textbf{QUICKSORT:} If \texttt{left >= right} (R1 >= R2), it returns via \texttt{BPL QS\_RET}. Otherwise it saves R4--R8 and LR with \texttt{STMFD}, keeps base/left/right in R4--R6, calls \texttt{PARTITION} (pivot index returned in R3), stores the pivot index in R7, then performs two recursive calls: first with right = R7 - 1, then with left = R7 + 1. It restores registers and returns.
    \item \textbf{PARTITION:} Saves R4--R12 and LR. Pivot value is \texttt{A[right]} in R7; index \texttt{i = left - 1} in R9, \texttt{j = left} in R10. Loop: load \texttt{A[j]}; if \texttt{A[j] > pivot} skip to \texttt{P\_NEXT}; else increment i, then swap \texttt{A[i]} and \texttt{A[j]}. After the loop, swap \texttt{A[i+1]} and \texttt{A[right]}, set R3 = i+1 (pivot index), restore registers and return.
    \item \textbf{Registers:} R0--R3 are used for arguments and return value (base, left, right, pivot index). R4--R6 hold base, left, right across calls in \texttt{QUICKSORT}. In \texttt{PARTITION}, R4--R6 are base/left/right, R7 is pivot value, R8 is \texttt{\&A[right]}, R9 is i, R10 is j, R11--R12 for addresses and values during the loop.
\end{itemize}

\begin{lstlisting}
Data      DCD     10, 12, 8, 1, 5, 7, 11, 6, 8

          ;       call quicksort(Data, 0, 8)
          LDR     R0, =Data ; R0 = base address
          MOVS    R1, #0x00 ; left index
          MOVS    R2, #0x08 ; right index (9 elements -> last index 8)
          BL      QUICKSORT

          END

          ;       ------------------------------------------------------------
          ;       void QUICKSORT(int *base, int left, int right)
          ;       R0 = base pointer
          ;       R1 = left index
          ;       R2 = right index
          ;       ------------------------------------------------------------
QUICKSORT
          CMP     R1, R2
          BPL     QS_RET ; if left >= right, return

          STMFD   SP!, {R4-R8, LR} ; save working regs + return
          MOV     R4, R0 ; keep base
          MOV     R5, R1 ; keep left
          MOV     R6, R2 ; keep right

          ;       partition(base, left, right) -> pivotIndex in R3
          BL      PARTITION
          MOV     R7, R3 ; pivot index

          ;       quicksort(base, left, pivotIndex-1)
          MOV     R0, R4
          MOV     R1, R5
          SUB     R2, R7, #0x01
          BL      QUICKSORT

          ;       quicksort(base, pivotIndex+1, right)
          MOV     R0, R4
          ADD     R1, R7, #0x01
          MOV     R2, R6
          BL      QUICKSORT

          LDMFD   SP!, {R4-R8, LR}
QS_RET
          MOV     PC, LR

          ;       ------------------------------------------------------------
          ;       int PARTITION(int *base, int left, int right)
          ;       Lomuto partition:
          ;       pivot = A[right]
          ;       i = left - 1
          ;       for j in [left..right-1]:
          ;       if A[j] <= pivot: i++; swap(A[i], A[j])
          ;       swap(A[i+1], A[right]); return i+1
          ;
          ;       Inputs:
          ;       R0 = base pointer
          ;       R1 = left index
          ;       R2 = right index
          ;       Output:
          ;       R3 = pivot index
          ;       Clobbers:
          ;       R4-R12
          ;       ------------------------------------------------------------
PARTITION
          STMFD   SP!, {R4-R12, LR}

          MOV     R4, R0 ; base
          MOV     R5, R1 ; left
          MOV     R6, R2 ; right

          ;       pivot = A[right]
          MOV     R8, R6
          LSL     R8, R8, #0x02 ; right * 4
          ADD     R8, R4, R8 ; &A[right]
          LDR     R7, [R8] ; pivot value

          ;       i = left - 1
          SUB     R9, R5, #0x01 ; i
          MOV     R10, R5 ; j = left

P_LOOP
          CMP     R10, R6
          BPL     P_DONE ; j >= right -> finish

          ;       load A[j]
          MOV     R11, R10
          LSL     R11, R11, #0x02 ; j * 4
          ADD     R11, R4, R11 ; &A[j]
          LDR     R12, [R11] ; A[j]

          CMP     R12, R7
          BGT     P_NEXT ; if A[j] > pivot, no swap

          ;       i++
          ADD     R9, R9, #0x01

          ;       swap A[i] and A[j]
          MOV     R0, R9
          LSL     R0, R0, #0x02 ; i * 4
          ADD     R0, R4, R0 ; &A[i]
          LDR     R1, [R0] ; tmp = A[i]
          STR     R12, [R0] ; A[i] = A[j]
          STR     R1, [R11] ; A[j] = tmp

P_NEXT
          ADD     R10, R10, #0x01 ; j++
          B       P_LOOP

P_DONE
          ;       swap A[i+1] and A[right]
          ADD     R9, R9, #0x01 ; i+1

          MOV     R0, R9
          LSL     R0, R0, #0x02
          ADD     R0, R4, R0 ; &A[i+1]
          LDR     R1, [R0] ; tmp = A[i+1]
          STR     R7, [R0] ; A[i+1] = pivot
          STR     R1, [R8] ; A[right] = tmp

          MOV     R3, R9 ; return pivot index

          LDMFD   SP!, {R4-R12, LR}
          MOV     PC, LR
\end{lstlisting}

\subsection*{Output Result}

After assembling and running the program in the visUAL2 emulator, the \texttt{Data} array in memory contains the sorted sequence:

\textbf{1, 5, 6, 7, 8, 8, 10, 11, 12}

The program was assembled and run in the visUAL2 emulator; the sorted sequence can be verified by inspecting the memory at the label \texttt{Data} after execution.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{memory_init.png}
    \caption{visUAL2: initial memory (before run).}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth]{memory_dump.png}
    \caption{visUAL2: memory after execution (sorted \texttt{Data}).}
\end{figure}
The assembly was written by hand from the C source and tested in visUAL2.

\end{document}
